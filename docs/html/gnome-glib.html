<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.1, http://www.gnu.org/software/texinfo/ -->
<head>
<title>guile-a-sync2: gnome glib</title>

<meta name="description" content="guile-a-sync2: gnome glib">
<meta name="keywords" content="guile-a-sync2: gnome glib">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="index.html#Top" rel="start" title="Top">
<link href="index.html#Top" rel="up" title="Top">
<link href="compose.html#compose" rel="next" title="compose">
<link href="monotonic-time.html#monotonic-time" rel="prev" title="monotonic time">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
blockquote.smallindentedblock {margin-right: 0em; font-size: smaller}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smalllisp {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
ul.no-bullet {list-style: none}
-->
</style>


</head>

<body lang="en">
<a name="gnome-glib"></a>
<div class="header">
<p>
Next: <a href="compose.html#compose" accesskey="n" rel="next">compose</a>, Previous: <a href="monotonic-time.html#monotonic-time" accesskey="p" rel="prev">monotonic time</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>
<hr>
<h4 class="node-heading">gnome glib</h4>

<p>When using the scheme (gnome gtk) bindings of guile-gnome with guile,
in order to provide await semantics on gtk+ callbacks it will normally
be necessary to use the &rsquo;await&rsquo; and &rsquo;resume&rsquo; procedures provided by
the a-sync procedure in the <a href="coroutines.html#coroutines">(a-sync coroutines)</a>
module directly (calling &rsquo;resume&rsquo; in the gtk+ callback when ready, and
waiting on that callback using &rsquo;await&rsquo;).  However when launching
timeouts, file watches or idle events on the glib main loop,
convenience procedures are possible similar to those provided for the
event loop in the <a href="event-loop.html#event-loop">(a-sync event-loop)</a> module.  These
are set out below.
</p>
<p>Note that the g-idle-add procedure in guile-gnome is suspect - there
appears to be a garbage collection issue, and if you call the
procedure often enough in a single or multi-threaded program it will
eventually segfault.  g-io-add-watch is also broken in guile-gnome, so
this library uses its own glib-add-watch procedure which is exported
publicly in case it is useful to users.
</p>
<p>All the other scheme files provided by this library are by default
compiled by this library to bytecode.  That is not the case with this
module, so as not to create a hard dependency on guile-gnome.
</p>
<p>Including this module will automatically enable suspendable ports in
order to support the await-glib-read-suspendable,
await-glib-write-suspendable and await-glib-getline procedures.  To
disable suspendable ports again, uninstall-suspendable-ports! can be
called, but this means that those procedures can no longer be used
while suspendable ports are disabled.  In addition, any port using
those procedures must be made non-blocking using fcntl as follows:
</p>
<div class="example">
<pre class="example">(fcntl [port] F_SETFL (logior O_NONBLOCK
                      (fcntl [port] F_GETFL)))
</pre></div>

<p>The (a-sync gnome-glib) module provides the following procedures:
</p>
<dl>
<dt><a name="index-await_002dglib_002dtask_002din_002dthread"></a>Scheme Procedure: <strong>await-glib-task-in-thread</strong> <em>await resume thunk [handler]</em></dt>
<dd><p>This is a convenience procedure which will run &rsquo;thunk&rsquo; in its own
thread, and then post an event to the default glib main loop when
&rsquo;thunk&rsquo; has finished.  This procedure calls &rsquo;await&rsquo; and will return
the thunk&rsquo;s return value.  It is intended to be called in a waitable
procedure invoked by a-sync.  If the optional &rsquo;handler&rsquo; argument is
provided, then it will be run in the event loop thread if &rsquo;thunk&rsquo;
throws and its return value will be the return value of this
procedure; otherwise the program will terminate if an unhandled
exception propagates out of &rsquo;thunk&rsquo;.  &rsquo;handler&rsquo; should take the same
arguments as a guile catch handler (this is implemented using catch).
</p>
<p>This procedure must (like the a-sync procedure) be called in the same
thread as that in which the default glib main loop runs, where the
result of calling &rsquo;thunk&rsquo; will be received.  As mentioned above, the
thunk itself will run in its own thread.
</p>
<p>Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the worker thread starts), which shouldn&rsquo;t
happen unless memory is exhausted or pthread has run out of resources.
Exceptions arising during execution of the task, if not caught by a
handler procedure, will terminate the program.  Exceptions thrown by
the handler procedure will propagate out of g-main-loop-run.
</p>
<p>This procedure uses g-idle-add: see the introductory remarks about
that.
</p>
<p>Here is an example of the use of await-glib-task-in-thread:
</p><div class="example">
<pre class="example">(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
	  (simple-format #t &quot;1 + 1 is ~A\n&quot;
			 (await-glib-task-in-thread await resume
						    (lambda ()
						      (+ 1 1))))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-await_002dglib_002dtask"></a>Scheme Procedure: <strong>await-glib-task</strong> <em>await resume thunk</em></dt>
<dd><p>This is a convenience procedure for use with glib, which will run
&rsquo;thunk&rsquo; in the default glib main loop.  This procedure calls &rsquo;await&rsquo;
and will return the thunk&rsquo;s return value.  It is intended to be called
in a waitable procedure invoked by a-sync.  It is the single-threaded
corollary of await-glib-task-in-thread.  This means that (unlike with
await-glib-task-in-thread) while &rsquo;thunk&rsquo; is running other events in
the main loop will not make progress, so blocking calls should not be
made in &rsquo;thunk&rsquo;.
</p>
<p>This procedure must (like the a-sync procedure) be called in the same
thread as that in which the default glib main loop runs.
</p>
<p>Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the task starts), which shouldn&rsquo;t happen
unless memory is exhausted.  Exceptions arising during execution of
the task, if not caught locally, will propagate out of
g-main-loop-run.
</p>
<p>This procedure uses g-idle-add: see the introductory remarks about
that.
</p>
<p>Here is an example of the use of await-glib-task:
</p><div class="example">
<pre class="example">(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
	  (simple-format #t &quot;1 + 1 is ~A\n&quot;
			 (await-glib-task await resume
					  (lambda ()
					    (+ 1 1))))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-await_002dglib_002dtimeout"></a>Scheme Procedure: <strong>await-glib-timeout</strong> <em>await resume msecs thunk</em></dt>
<dd><p>This is a convenience procedure for use with a glib main loop, which
will run &rsquo;thunk&rsquo; in the default glib main loop when the timeout
expires.  This procedure calls &rsquo;await&rsquo; and will return the thunk&rsquo;s
return value.  It is intended to be called in a waitable procedure
invoked by a-sync.  The timeout is single shot only - as soon as
&rsquo;thunk&rsquo; has run once and completed, the timeout will be removed from
the event loop.
</p>
<p>This procedure must (like the a-sync procedure) be called in the same
thread as that in which the default glib main loop runs.
</p>
<p>Exceptions may propagate out of this procedure if they arise while
setting up (that is, before the first call to &rsquo;await&rsquo; is made), which
shouldn&rsquo;t happen unless memory is exhausted.  Exceptions thrown by
&rsquo;thunk&rsquo;, if not caught locally, will propagate out of g-main-loop-run.
</p>
<p>Here is an example of the use of await-glib-timeout:
</p><div class="example">
<pre class="example">(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
	  (simple-format #t
			 &quot;Timeout ~A\n&quot;
			 (await-glib-timeout await resume
					     100
					     (lambda ()
					       &quot;expired&quot;)))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-glib_002dadd_002dwatch"></a>Scheme Procedure: <strong>glib-add-watch</strong> <em>ioc cond func [context]</em></dt>
<dd><p>This procedure replaces guile-gnome&rsquo;s g-io-add-watch procedure, which
won&rsquo;t compile.  It attaches a watch on a g-io-channel object to the
main context provided, or if none is provided, to the default glib
main context (the main program loop).  It returns a glib ID which can
be passed subsequently to the g-source-remove procedure.  It should be
possible to call this procedure in any thread.
</p>
<p>File watches in guile-gnome are implemented using a GIOChannel object,
and unfortunately GIOChannel support in guile-gnome is decaying.  The
only procedure that guile-gnome provides to read from a GIOChannel
object is g-io-channel-read-line, which does not work.  One is
therefore usually left with having to read from a guile port (whose
underlying file descriptor is &rsquo;fd&rsquo;) using guile&rsquo;s port input
procedures, but this has its own difficulties, which means that one of
the following approaches should be adopted (i) the port has to be
unbuffered (say by using the open-file or fdopen procedure with the
&rsquo;0&rsquo; mode option or the R6RS open-file-input-port procedure with a
buffer-mode of none, or by calling setvbuf), or (ii) &rsquo;proc&rsquo; must deal
with everything in the port&rsquo;s buffer by calling drain-input, or by
looping on char-ready? before returning, or (iii) the port&rsquo;s ordinary
input procedures should be used with suspendable ports using the
await-glib-read-suspendable procedure.  This is because otherwise, if
the port is buffered, once the port is read from there may be further
characters in the buffer to be dealt with even though the GIOChannel
watch does not trigger because there is nothing new to make the file
descriptor ready for reading.
</p></dd></dl>

<dl>
<dt><a name="index-await_002dglib_002dread_002dsuspendable"></a>Scheme Procedure: <strong>await-glib-read-suspendable</strong> <em>await resume port proc</em></dt>
<dd><p>&rsquo;proc&rsquo; is a procedure taking a single argument, to which the port will
be passed when func is invoked.  &rsquo;port&rsquo; must be a suspendable
non-blocking port.  &rsquo;proc&rsquo; will be executed whenever there is
something available to read, and this procedure will return when
&rsquo;proc&rsquo; returns, as if by a blocking read.  The glib event loop will
not be blocked by this procedure even if only individual characters or
bytes comprising part characters are available at any one time.  It is
intended to be called in a waitable procedure invoked by a-sync.
</p>
<p>This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.
</p>
<p>Exceptions (say, because of port or conversion errors) will propagate
out of this procedure in the first instance, and if not caught locally
will then propagate out of g-main-loop-run.
</p>
<p>As an example of how to use await-glib-read-suspendable, here is the
implementation of await-glib-getline:
</p>
<div class="example">
<pre class="example">(define (await-glib-getline await resume port)
  (await-glib-read-suspendable await resume port
			       (lambda (p)
				 (read-line p))))
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-await_002dglib_002dgetline"></a>Scheme Procedure: <strong>await-glib-getline</strong> <em>await resume port</em></dt>
<dd><p>This procedure is provided mainly to retain compatibility with the
guile-a-sync library for guile-2.0, because it is trivial to implement
with await-glib-read-suspendable (and is implemented by
await-glib-read-suspendable).
</p>
<p>It is intended to be called in a waitable procedure invoked by a-sync,
and reads a line of text from a non-blocking suspendable port and
returns it (without the terminating &rsquo;\n&rsquo; character).  See the
documentation on the await-glib-read-suspendable procedure for further
particulars about this procedure.
</p>
<p>Here is an example of the use of await-glib-getline:
</p><div class="example">
<pre class="example">(define main-loop (g-main-loop-new #f #f))
(a-sync (lambda (await resume)
          (display &quot;Enter a line of text at the keyboard\n&quot;)
	  (let ((port (open &quot;/dev/tty&quot; O_RDONLY)))
	    (fcntl port F_SETFL (logior O_NONBLOCK
				(fcntl port F_GETFL)))
	    (simple-format #t
			   &quot;The line was: ~A\n&quot;
			   (await-glib-getline await resume
					       port)))
	  (g-main-loop-quit main-loop)))
(g-main-loop-run main-loop)
</pre></div>
</dd></dl>

<dl>
<dt><a name="index-await_002dglib_002dwrite_002dsuspendable"></a>Scheme Procedure: <strong>await-glib-write-suspendable</strong> <em>await resume port proc</em></dt>
<dd><p>&rsquo;proc&rsquo; is a procedure taking a single argument, to which the port will
be passed when func is invoked.  &rsquo;port&rsquo; must be a suspendable
non-blocking port.  &rsquo;proc&rsquo; will be executed whenever the port is
available to write to, and this procedure will return when &rsquo;proc&rsquo;
returns, as if by a blocking write.  The glib event loop will not be
blocked by this procedure even if only individual characters or bytes
comprising part characters can be written at any one time.  It is
intended to be called in a waitable procedure invoked by a-sync.
</p>
<p>This procedure must (like the a-sync procedure) be called in the same
thread as that in which the event loop runs.
</p>
<p>Exceptions (say, because of port or conversion errors) will propagate
out of this procedure in the first instance, and if not caught locally
will then propagate out of g-main-loop-run.
</p></dd></dl>
<hr>
<div class="header">
<p>
Next: <a href="compose.html#compose" accesskey="n" rel="next">compose</a>, Previous: <a href="monotonic-time.html#monotonic-time" accesskey="p" rel="prev">monotonic time</a>, Up: <a href="index.html#Top" accesskey="u" rel="up">Top</a> &nbsp; </p>
</div>



</body>
</html>
